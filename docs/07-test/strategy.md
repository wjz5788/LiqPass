# 最小测试策略文档

## 文档概述

**文档目的**：定义LiqPass项目的测试策略，确保系统质量、功能完整性和业务连续性。
**适用对象**：开发团队、测试团队、运维团队
**文档版本**：v1.0
**最后更新**：2024-12-19

## 1. 测试策略总览

### 1.1 测试目标
- **功能完整性**：确保所有核心业务流程正常运作
- **数据一致性**：保证跨系统数据同步和一致性
- **安全合规**：验证API密钥管理、交易验证等安全机制
- **性能稳定**：确保系统在高并发场景下的稳定性

### 1.2 测试范围
- **前端测试**：React组件、用户交互、API调用
- **后端测试**：API接口、业务逻辑、数据库操作
- **智能合约测试**：合约逻辑、事件触发、安全验证
- **集成测试**：跨系统集成、端到端流程

### 1.3 测试层级
```
单元测试 → 集成测试 → 端到端测试
```

## 2. 前端测试策略

### 2.1 测试框架配置
- **测试框架**：Jest + React Testing Library
- **测试环境**：jsdom模拟浏览器环境
- **覆盖率目标**：核心组件80%以上

### 2.2 核心测试组件

#### 2.2.1 页面组件测试
- **Home页面**：渲染测试、导航测试
- **Products页面**：产品列表展示、筛选功能
- **OrderHistory页面**：订单历史数据展示
- **Settings页面**：API密钥配置测试

#### 2.2.2 业务组件测试
- **QuoteCalculator**：保费计算逻辑测试
- **PLFlow**：盈亏流程组件测试
- **WalletConnectButton**：钱包连接功能测试

#### 2.2.3 上下文测试
- **ApiKeyContext**：API密钥管理测试
- **WalletContext**：钱包状态管理测试

### 2.3 测试示例代码

```typescript
// OrderHistory组件测试示例
describe('OrderHistory Component', () => {
  it('should render order list correctly', () => {
    render(<OrderHistory />);
    expect(screen.getByText('订单历史')).toBeInTheDocument();
  });
  
  it('should display empty state when no orders', () => {
    render(<OrderHistory />);
    expect(screen.getByText('暂无订单')).toBeInTheDocument();
  });
});
```

## 3. 后端测试策略

### 3.1 US后端测试

#### 3.1.1 测试框架配置
- **测试框架**：Jest + Supertest
- **数据库**：SQLite内存数据库
- **覆盖率目标**：核心API 85%以上

#### 3.1.2 核心API测试
- **健康检查接口**：`GET /healthz`
- **产品目录接口**：`GET /catalog/skus`
- **订单创建接口**：`POST /orders`
- **赔付申请接口**：`POST /claims`
- **验证状态接口**：`GET /verification/:orderId`

#### 3.1.3 业务逻辑测试
- **保费计算逻辑**：基于杠杆倍数和保额
- **赔付验证逻辑**：价格波动验证
- **订单状态流转**：创建→验证→赔付流程

#### 3.1.4 测试示例代码

```javascript
// 服务器API测试示例
describe('Server API', () => {
  describe('GET /healthz', () => {
    it('should return health status', async () => {
      const response = await request(app)
        .get('/healthz')
        .expect(200);
      
      expect(response.body).toHaveProperty('status', 'ok');
      expect(response.body).toHaveProperty('payoutMode');
    });
  });
});
```

### 3.2 JP验证服务测试

#### 3.2.1 测试重点
- **交易所API集成**：Binance/OKX价格获取
- **验证逻辑**：价格波动计算
- **错误处理**：API调用失败处理

## 4. 智能合约测试策略

### 4.1 测试框架
- **测试框架**：Hardhat + Waffle
- **网络环境**：本地Hardhat网络
- **覆盖率目标**：核心函数90%以上

### 4.2 核心合约测试

#### 4.2.1 LeverageGuard合约测试
- **创建保险单**：`createPolicy`函数
- **触发赔付**：`triggerPayout`函数
- **状态管理**：保单状态流转
- **事件触发**：PolicyCreated、PayoutTriggered事件

#### 4.2.2 安全测试
- **重入攻击防护**
- **权限控制验证**
- **边界条件测试**

#### 4.2.3 测试示例代码

```solidity
// 智能合约测试示例
describe("LeverageGuard", function () {
  it("Should create a new policy", async function () {
    const policy = await leverageGuard.createPolicy(
      user.address,
      ethers.utils.parseEther("1"),
      24 * 60 * 60
    );
    
    expect(await leverageGuard.getPolicyCount()).to.equal(1);
  });
});
```

## 5. 集成测试策略

### 5.1 端到端流程测试

#### 5.1.1 核心业务流程
1. **用户注册与钱包连接**
2. **产品浏览与保费计算**
3. **保险单创建与支付**
4. **价格验证与状态更新**
5. **赔付申请与处理**

#### 5.1.2 测试工具
- **Playwright**：浏览器自动化测试
- **测试数据**：模拟交易数据、价格数据

#### 5.1.3 测试场景
- **正常流程**：完整保险购买到赔付流程
- **边界情况**：价格刚好触及赔付阈值
- **异常处理**：网络中断、API失败等

### 5.2 跨系统集成测试

#### 5.2.1 前端-后端集成
- **API调用验证**：请求/响应格式
- **错误处理集成**：统一错误码处理
- **数据同步验证**：订单状态同步

#### 5.2.2 后端-区块链集成
- **合约调用验证**：交易创建、状态查询
- **事件监听测试**：合约事件处理
- **Gas费用优化**：交易成本控制

## 6. 性能测试策略

### 6.1 负载测试
- **并发用户数**：模拟100+并发用户
- **API响应时间**：关键API < 500ms
- **数据库性能**：查询优化、索引验证

### 6.2 压力测试
- **峰值流量**：模拟市场波动时的流量高峰
- **资源监控**：CPU、内存、网络使用率
- **弹性测试**：自动扩缩容能力

## 7. 安全测试策略

### 7.1 API安全测试
- **认证授权**：API密钥验证、权限控制
- **输入验证**：SQL注入、XSS防护
- **数据加密**：敏感信息加密传输

### 7.2 智能合约安全测试
- **常见漏洞**：重入、整数溢出、权限提升
- **代码审计**：第三方安全审计
- **形式化验证**：关键逻辑数学证明

## 8. 测试数据管理

### 8.1 测试数据分类
- **静态数据**：产品信息、费率表
- **动态数据**：价格数据、用户数据
- **模拟数据**：测试用例专用数据

### 8.2 数据隔离策略
- **测试数据库**：与生产环境隔离
- **数据清理**：测试后自动清理
- **数据版本控制**：测试数据版本管理

## 9. 测试环境管理

### 9.1 环境分类
- **本地开发环境**：开发者本地测试
- **集成测试环境**：功能集成测试
- **预生产环境**：生产前最终验证

### 9.2 环境配置
- **环境变量管理**：不同环境配置分离
- **依赖服务Mock**：外部服务模拟
- **网络配置**：本地网络、测试网络

## 10. 测试执行与报告

### 10.1 测试执行流程
```
代码提交 → 自动测试 → 测试报告 → 质量门禁
```

### 10.2 测试报告指标
- **测试覆盖率**：代码行覆盖率、分支覆盖率
- **测试通过率**：测试用例执行结果
- **缺陷统计**：严重程度、修复状态

### 10.3 质量门禁
- **单元测试通过率**：> 90%
- **集成测试通过率**：100%
- **代码覆盖率**：核心模块 > 80%

## 11. 持续集成/持续部署

### 11.1 CI/CD流水线
- **代码检查**：ESLint、Prettier
- **单元测试**：自动执行所有单元测试
- **集成测试**：端到端流程验证
- **部署验证**：生产环境健康检查

### 11.2 自动化测试触发
- **代码推送**：自动触发相关测试
- **定时执行**：每日构建和测试
- **手动触发**：特定版本测试

## 12. 测试工具与技术栈

### 12.1 测试工具列表
| 测试类型 | 工具 | 用途 |
|---------|------|------|
| 单元测试 | Jest, React Testing Library | 组件和函数测试 |
| 集成测试 | Supertest, Playwright | API和E2E测试 |
| 合约测试 | Hardhat, Waffle | 智能合约测试 |
| 性能测试 | k6, Artillery | 负载和压力测试 |
| 安全测试 | OWASP ZAP, Slither | 安全漏洞检测 |

### 12.2 测试依赖管理
- **测试依赖隔离**：测试专用依赖包
- **版本控制**：测试工具版本锁定
- **环境一致性**：开发、测试、生产环境一致

## 13. 风险控制与应急预案

### 13.1 测试风险识别
- **测试覆盖不足**：关键路径未测试
- **环境差异**：测试与生产环境不一致
- **数据污染**：测试数据影响生产

### 13.2 应急预案
- **测试失败处理**：快速定位和修复
- **回滚机制**：测试失败自动回滚
- **监控告警**：测试异常实时告警

## 14. 测试团队与职责

### 14.1 团队分工
- **开发团队**：单元测试、集成测试编写
- **测试团队**：E2E测试、性能测试执行
- **运维团队**：测试环境维护、监控

### 14.2 质量文化
- **测试左移**：开发阶段介入测试
- **质量意识**：全员参与质量保证
- **持续改进**：测试策略定期评审

## 15. 附录

### 15.1 测试用例模板
```markdown
# 测试用例：[功能名称]

## 测试目标
[描述测试目的]

## 前置条件
[测试环境要求]

## 测试步骤
1. [步骤1]
2. [步骤2]
3. [步骤3]

## 预期结果
[期望的输出或行为]

## 实际结果
[实际测试结果]

## 测试状态
[通过/失败/阻塞]
```

### 15.2 测试报告模板
```markdown
# 测试报告：[版本号]

## 执行概况
- 测试时间：
- 测试环境：
- 测试范围：

## 测试结果统计
- 总用例数：
- 通过数：
- 失败数：
- 通过率：

## 缺陷统计
- 严重缺陷：
- 一般缺陷：
- 建议改进：

## 风险评估
[发布风险评估]

## 建议
[发布建议]
```

---

**文档维护**：测试策略应随项目演进定期更新，确保与最新业务需求和技术架构保持一致。